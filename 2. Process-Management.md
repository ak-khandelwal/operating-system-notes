# Introduction

A program under execution. Process is an `active` entity while program is a `passive` entity.

# How a process look like inside a memory

A process in memory is divided into several distinct sections, each serving a different purpose.

| Memory Segment | Typical Contents                                         | Growth Direction |
| -------------- | -------------------------------------------------------- | ---------------- |
| Stack          | Local variables, function call info                      | ↓ (Downward)     |
| Heap           | Dynamically allocated memory (e.g., using malloc or new) | ↑ (Upward)       |
| Data           | Global and static variables                              | Fixed size       |
| Text           | Executable instructions (Program Code)                   | Fixed size       |

# Operations on a Process

1. Create
2. Schedule, Run
3. Wait/Block
4. Suspend, Resume,career ride time and work
5. Terminate (Resource Deallocation)

# Attributes of a Process

A process has several important attributes that help the operating system manage and control it. These attributes are stored in a structure called the Process Control Block (PCB) (sometimes called a task control block).

eg. pid, type of process (foreground or background),size, priority

# Context

The content of PCB of a process are collectivly known as "context" of that process.

# Context Switching

Context switching is the process where the CPU stops running one process, saves its current state, and loads the saved state of another process so that multiple processes can share the CPU effectively.

# Process States

1. **New** – The program is stored on disk (e.g., HDD/SSD) and is ready to be brought into memory.
2. **Ready** – The process has been loaded into RAM and is waiting for CPU scheduling.
3. **Running** – The CPU is currently executing the process instructions.
4. **Waiting (Blocked)** – The process is paused, waiting for an I/O operation or an event to complete.
5. **Terminated** – The process has finished execution and is removed from memory.

## Process State Transitions for preemptive system

- **New → Ready:** When the process is admitted by the operating system.
- **Ready → Running:** When the process is dispatched to the CPU.
- **Running → Terminated:** When the process completes its execution. ( done by process itself)
- **Running → Blocked:** When the process requests an I/O operation or waits for an event. (done by process itself)
- **Running → Ready:** When the process is preempted (CPU taken away by the scheduler).
- **Blocked → Ready:** When the process finishes its I/O operation or the awaited event occurs.

## Process State Transition for non-preemptive system

- **Running -> Ready:** This state does not exists

# I/O-bound vs CPU-bound Processes

- **CPU-bound:** A process that spends most of its time performing calculations and CPU-intensive tasks.

  - **Example:** Rendering a 3D scene, performing large matrix multiplications, or running complex simulations.

- **I/O-bound:** A process that spends most of its time waiting for input/output operations to complete.
  - **Example:** Reading/writing large files from disk, waiting for network responses, or interacting with a database.

# Process Scheduling

Process scheduling in an operating system (OS) is the method by which the OS decides which process runs on the CPU and for how long. Since multiple processes may be ready to execute but the CPU can execute only one at a time, scheduling ensures efficient CPU utilization and fairness among processes.

## Scheduling Queues

These queues are maintained by the OS in **main memory** to manage processes at different states:

- **Job Queue** – Contains all processes in the system that are in the **new** state, waiting to be admitted to the ready queue.
- **Ready Queue** – Contains all processes that are in the **ready state**, waiting for **CPU allocation**.
- **Device Queue (or I/O Queue)** – Contains all processes that are **waiting for a particular I/O device** to become available.

**Notes:**

- There can be **multiple device queues**, one per I/O device.
- The **OS scheduler** moves processes between these queues based on events like CPU completion, I/O request, or process termination.

## Types of Scheduling

1. **Long-term Scheduling**

   - Controls the **admission of processes** into the system.
   - Determines **which jobs from the job queue** are moved to the ready queue.
   - Runs **less frequently**.
   - Goal: Maintain a **balanced mix of CPU-bound and I/O-bound processes**.

2. **Short-term Scheduling**

   - Also called **CPU scheduling**.
   - Decides **which process in the ready queue gets CPU next**.
   - Runs **very frequently** (milliseconds).
   - Goal: Ensure **efficient CPU utilization and quick response**.

3. **Medium-term Scheduling**
   - Temporarily **removes (suspends) or resumes processes** to manage system load.
   - Runs **occasionally** to improve **process mix and performance**.
   - Goal: Balance **CPU and I/O processes** and free resources when needed.

## Goal of Process/CPU Scheduling

- Minimize the waiting time and turn around time
- Maximize CPU utilization (throughput)
- fairness

## Scheduling Times

1. **Arrival Time** - The time at which the process arrives in the system.
2. **Burst Time** - The amount of time for which process runs on CPU.
3. **Completion Time/ Exit Time** - The time at which process completes.
4. **Turn Around Time** - Time from arrival to completion. (Completion time - arrival time)
5. **Waiting Time** - Total time a process spend outside CPU. (TAT - BT)
6. **Response Time** - Amount of time from arrival till first time process gets the CPU.
7. **Scheduling Length (L)** - Max(CT) - Min(AT)
8. **Throughput** - Number of processes executed per unit of time. (total number of processes (n) / L)

## Scheduling Algorithms

### FCFS(First Come First Serve)

- **Criteria**: Arrival Time
  - **Time Breaker**: smaller ID first
- **Type**:Non-preemptive

#### Problem 1

| Process | Arrival Time | Burst Time | Completion Time | Turnaround Time | Waiting Time |
| ------- | ------------ | ---------- | --------------- | --------------- | ------------ |
| P1      | 0            | 30         |                 |                 |              |
| P2      | 0            | 5          |                 |                 |              |
| P3      | 0            | 5          |                 |                 |              |

make the gantt chart and find response time, Scheduling length and throughput.

#### Problem 2

| Process | Arrival Time | Burst Time | Completion Time | Turnaround Time | Waiting Time |
| ------- | ------------ | ---------- | --------------- | --------------- | ------------ |
| P1      | 0            | 4          |                 |                 |              |
| P2      | 1            | 2          |                 |                 |              |
| P3      | 2            | 3          |                 |                 |              |
| P4      | 3            | 5          |                 |                 |              |
| P5      | 4            | 6          |                 |                 |              |
| P6      | 5            | 1          |                 |                 |              |

make the gantt chart and find response time, Scheduling length and throughput.

#### Problem 3

| Process | Arrival Time | Burst Time | Completion Time | Turnaround Time | Waiting Time |
| ------- | ------------ | ---------- | --------------- | --------------- | ------------ |
| P1      | 4            | 4          |                 |                 |              |
| P2      | 8            | 2          |                 |                 |              |
| P3      | 6            | 3          |                 |                 |              |
| P4      | 5            | 3          |                 |                 |              |
| P5      | 2            | 1          |                 |                 |              |
| P6      | 7            | 7          |                 |                 |              |

make the gantt chart and find response time, Scheduling length and throughput.

#### Convoy Effect

The convoy effect in FCFS (First-Come, First-Served) is a phenomenon where a long-running process at the front of the queue delays all subsequent processes, even if they are much shorter

# Questions

## Unicore vs multicore processor

A **multi-core processor** has multiple cores in one CPU, allowing it to run several tasks simultaneously. This improves performance, multitasking, and efficiency compared to single-core processors.

## Does multiple cores mean multiple CPSs ?

Multiple cores don’t mean multiple CPUs — they’re multiple processing units within a single CPU chip, sharing memory and resources but handling tasks in parallel for faster performance.

## Which of the following state is/are initiated by process itself ?

1. Running
2. Ready
3. Terminated
4. Blocked

**ans:** 3 & 4

## A process which has just terminated but has to relinquish its resource is called ?

1. Suspended Process
2. Zombie Process
3. Blocked Process
4. Terminated Process

**ans:** 2

## Which scheduler reduces the degree of multi-programming ?

1. short-term
2. long-term
3. mid-term
4. long-term and mid-term both

**ans:** 3
