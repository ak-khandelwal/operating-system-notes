# Introduction

A program under execution. Process is an `active` entity while program is a `passive` entity.

# How a process look like inside a memory

A process in memory is divided into several distinct sections, each serving a different purpose.

| Memory Segment | Typical Contents                                         | Growth Direction |
| -------------- | -------------------------------------------------------- | ---------------- |
| Stack          | Local variables, function call info                      | ↓ (Downward)     |
| Heap           | Dynamically allocated memory (e.g., using malloc or new) | ↑ (Upward)       |
| Data           | Global and static variables                              | Fixed size       |
| Text           | Executable instructions (Program Code)                   | Fixed size       |

# Operations on a Process

1. Create
2. Schedule, Run
3. Wait/Block
4. Suspend, Resume,career ride time and work
5. Terminate (Resource Deallocation)

# Attributes of a Process

A process has several important attributes that help the operating system manage and control it. These attributes are stored in a structure called the Process Control Block (PCB) (sometimes called a task control block).

eg. pid, type of process (foreground or background),size, priority

# Context

The content of PCB of a process are collectivly known as "context" of that process.

# Context Switching

Context switching is the process where the CPU stops running one process, saves its current state, and loads the saved state of another process so that multiple processes can share the CPU effectively.

# Process States

1. **New** – The program is stored on disk (e.g., HDD/SSD) and is ready to be brought into memory.
2. **Ready** – The process has been loaded into RAM and is waiting for CPU scheduling.
3. **Running** – The CPU is currently executing the process instructions.
4. **Waiting (Blocked)** – The process is paused, waiting for an I/O operation or an event to complete.
5. **Terminated** – The process has finished execution and is removed from memory.

## Process State Transitions for preemptive system

- **New → Ready:** When the process is admitted by the operating system.
- **Ready → Running:** When the process is dispatched to the CPU.
- **Running → Terminated:** When the process completes its execution. ( done by process itself)
- **Running → Blocked:** When the process requests an I/O operation or waits for an event. (done by process itself)
- **Running → Ready:** When the process is preempted (CPU taken away by the scheduler).
- **Blocked → Ready:** When the process finishes its I/O operation or the awaited event occurs.

## Process State Transition for non-preemptive system

- **Running -> Ready:** This state does not exists

# I/O-bound vs CPU-bound Processes

- **CPU-bound:** A process that spends most of its time performing calculations and CPU-intensive tasks.

  - **Example:** Rendering a 3D scene, performing large matrix multiplications, or running complex simulations.

- **I/O-bound:** A process that spends most of its time waiting for input/output operations to complete.
  - **Example:** Reading/writing large files from disk, waiting for network responses, or interacting with a database.

# Process Scheduling

Process scheduling in an operating system (OS) is the method by which the OS decides which process runs on the CPU and for how long. Since multiple processes may be ready to execute but the CPU can execute only one at a time, scheduling ensures efficient CPU utilization and fairness among processes.

## Scheduling Queues

These queues are maintained by the OS in **main memory** to manage processes at different states:

- **Job Queue** – Contains all processes in the system that are in the **new** state, waiting to be admitted to the ready queue.
- **Ready Queue** – Contains all processes that are in the **ready state**, waiting for **CPU allocation**.
- **Device Queue (or I/O Queue)** – Contains all processes that are **waiting for a particular I/O device** to become available.

**Notes:**

- There can be **multiple device queues**, one per I/O device.
- The **OS scheduler** moves processes between these queues based on events like CPU completion, I/O request, or process termination.

## Types of Scheduling

1. **Long-term Scheduling**

   - Controls the **admission of processes** into the system.
   - Determines **which jobs from the job queue** are moved to the ready queue.
   - Runs **less frequently**.
   - Goal: Maintain a **balanced mix of CPU-bound and I/O-bound processes**.

2. **Short-term Scheduling**

   - Also called **CPU scheduling**.
   - Decides **which process in the ready queue gets CPU next**.
   - Runs **very frequently** (milliseconds).
   - Goal: Ensure **efficient CPU utilization and quick response**.

3. **Medium-term Scheduling**
   - Temporarily **removes (suspends) or resumes processes** to manage system load.
   - Runs **occasionally** to improve **process mix and performance**.
   - Goal: Balance **CPU and I/O processes** and free resources when needed.

## Goal of Process/CPU Scheduling

- Minimize the waiting time and turn around time
- Maximize CPU utilization (throughput)
- fairness

## Scheduling Times

1. **Arrival Time** - The time at which the process arrives in the system.
2. **Burst Time** - The amount of time for which process runs on CPU.
3. **Completion Time/ Exit Time** - The time at which process completes.
4. **Turn Around Time** - Time from arrival to completion. (Completion time - arrival time)
5. **Waiting Time** - Total time a process spend outside CPU. (TAT - BT)
6. **Response Time** - Amount of time from arrival till first time process gets the CPU.
7. **Scheduling Length (L)** - Max(CT) - Min(AT)
8. **Throughput** - Number of processes executed per unit of time. (total number of processes (n) / L)

## Scheduling Algorithms

### FCFS(First Come First Serve)

First Come, First Serve (FCFS) is one of the simplest types of CPU scheduling algorithms. It is exactly what it sounds like: processes are attended to in the order in which they arrive in the ready queue, much like customers lining up at a grocery store.

- **Criteria**: Arrival Time
  - **Time Breaker**: smaller ID first
- **Type**:Non-preemptive

#### Problem 1

| Process | Arrival Time | Burst Time | Completion Time | Turnaround Time | Waiting Time |
| ------- | ------------ | ---------- | --------------- | --------------- | ------------ |
| P1      | 0            | 30         |                 |                 |              |
| P2      | 0            | 5          |                 |                 |              |
| P3      | 0            | 5          |                 |                 |              |

make the gantt chart and find response time, Scheduling length and throughput.

gantt table - p1(0-30),p2(30-35),p3(35-40)

#### Problem 2

| Process | Arrival Time | Burst Time | Completion Time | Turnaround Time | Waiting Time |
| ------- | ------------ | ---------- | --------------- | --------------- | ------------ |
| P1      | 0            | 4          |                 |                 |              |
| P2      | 1            | 2          |                 |                 |              |
| P3      | 2            | 3          |                 |                 |              |
| P4      | 3            | 5          |                 |                 |              |
| P5      | 4            | 6          |                 |                 |              |
| P6      | 5            | 1          |                 |                 |              |

make the gantt chart and find response time, Scheduling length and throughput.

gantt table - p1(0-4),p2(4-6),p3(6-9),p4(9-14),p5(14-20),p6(20-21)

#### Problem 3

| Process | Arrival Time | Burst Time | Completion Time | Turnaround Time | Waiting Time |
| ------- | ------------ | ---------- | --------------- | --------------- | ------------ |
| P1      | 4            | 4          |                 |                 |              |
| P2      | 8            | 2          |                 |                 |              |
| P3      | 6            | 3          |                 |                 |              |
| P4      | 5            | 3          |                 |                 |              |
| P5      | 2            | 1          |                 |                 |              |
| P6      | 7            | 7          |                 |                 |              |

make the gantt chart and find response time, Scheduling length and throughput.

gantt table - X(0-2),p5(2-3),X(3-4),p1(4-8),p4(8-11),p3(11-14),p6(14-21),p2(21-23)

#### Convoy Effect

The convoy effect in FCFS (First-Come, First-Served) is a phenomenon where a long-running process at the front of the queue delays all subsequent processes, even if they are much shorter

### SJF

Shortest Job First (SJF) or Shortest Job Next (SJN) is a scheduling process that selects the waiting process with the smallest execution time to execute next. This scheduling method may or may not be preemptive. Significantly reduces the average waiting time for other processes waiting to be executed.

- **Criteria** - BT(smallest BT process first)
  - **Tie-Breaker** - FCFS
- **Type** - non-preemptive

#### Problem 1

| Process | Arrival Time | Burst Time | Completion Time | Turnaround Time | Waiting Time |
| ------- | ------------ | ---------- | --------------- | --------------- | ------------ |
| P1      | 0            | 30         |                 |                 |              |
| P2      | 0            | 5          |                 |                 |              |
| P3      | 0            | 5          |                 |                 |              |

also find response time as well.

gantt table - p2(0-5),p3(5-10),p1(10-40)

#### Problem 2

| Process | Arrival Time | Burst Time | Completion Time | Turnaround Time | Waiting Time |
| ------- | ------------ | ---------- | --------------- | --------------- | ------------ |
| P1      | 0            | 6          |                 |                 |              |
| P2      | 0            | 3          |                 |                 |              |
| P3      | 1            | 4          |                 |                 |              |
| P4      | 2            | 2          |                 |                 |              |
| P5      | 3            | 1          |                 |                 |              |
| P6      | 4            | 5          |                 |                 |              |
| P7      | 6            | 2          |                 |                 |              |

gantt tabe - p2(0-3),p5(3-4),p4(4-6),p7(6-8),p3(8-12),p6(12-17),p1(17-23)

#### Problem 3

| Process | Arrival Time | Burst Time | Completion Time | Turnaround Time | Waiting Time |
| ------- | ------------ | ---------- | --------------- | --------------- | ------------ |
| P1      | 0            | 4          |                 |                 |              |
| P2      | 4            | 3          |                 |                 |              |
| P3      | 6            | 1          |                 |                 |              |
| P4      | 3            | 5          |                 |                 |              |
| P5      | 8            | 2          |                 |                 |              |

gannt table - p1(0-4),p2(4-7),p3(7-8),p5(8-10),p4(10-15)

### SRTF (Shortest Remaining Time First)

In SRTF, the process with the least time left to finish is selected to run. The running process continues until it finishes or a new process with a shorter remaining time arrives, ensuring the fastest finishing process always gets priority.

- **Criteria** - BT
  - **Tie-breaker** - FCFS
- **Type** - preemptive

#### Problem 1

| Process | Arrival Time | Burst Time |
| :-----: | :----------: | :--------: |
|   P1    |      0       |     6      |
|   P2    |      1       |     4      |
|   P3    |      2       |     1      |
|   P4    |      3       |     2      |
|   P5    |      4       |     1      |
|   P6    |      5       |     3      |

gantt chart - p1(0-1),P2(1-2),P3(2-3),P4(3-5),P5(5-6),P2(6-9),P6(9-12),P1(12-17)

#### Problem 2

Consider three CPU intensive processes, which require 10, 20 and 30 time units and arrive at times 0, 2 and 6 respectively. How many context switches are needed if the operating system implements a shortest remaining time first scheduling algorithm?

Do not count the context switches at time zero and at the end

(A) 1
(B) 2
(C) 3
(D) 4

#### Problem 3

Consider three processes (process id 0, 1, 2 respectively) with compute time bursts 2, 4 and 8 time units. All processes arrive at time zero. Consider the longest remaining time first (LRTF) scheduling algorithm. In LRTF ties are broken by giving priority to the process with the lowest process id. The average turn around time is:

(A) 13 units
(B) 14 units
(C) 15 units
(D) 16 units

#### Problem 4

An operating system uses shortest remaining time first scheduling algorithm for pre-emptive scheduling of processes. Consider the following set of processes with their arrival times and CPU burst times (in milliseconds):

| Process | Arrival Time | Burst Time | completion time | tat | waiting time |
| :-----: | :----------: | :--------: | :-------------: | :-: | :----------: |
|   P1    |      0       |     12     |       27        | 27  |      15      |
|   P2    |      2       |     4      |        6        |  4  |      0       |
|   P3    |      3       |     6      |       12        |  9  |      3       |
|   P4    |      8       |     5      |       17        |  9  |      4       |

The average waiting time (in milliseconds) of the processes is **15,0,3,4** .

gentt chart - p1(0-2),p2(2-6),p3(6-12),p4(12-17),p1(17-27)

### HRRN (Highest Response Ratio First )

HRRN is a non-preemptive scheduling algorithm that selects the process with the highest response ratio for execution next.

- **Objective** - Not only favors short jobs but decreases the WT of longer jobs.
- **Criteria** - response ratio
  - **Tie-breaker** - BT
- **RR (response ratio)** - (w + s) / s
  - **w** - waiting time
  - **s** - service/burst time

#### Problem 1

| Process | Arrival Time | Burst Time | Completion Time | Turnaround Time | Waiting Time |
| :-----: | :----------: | :--------: | :-------------: | :-------------: | :----------: |
|   P1    |      0       |     3      |                 |                 |              |
|   P2    |      2       |     6      |                 |                 |              |
|   P3    |      4       |     4      |                 |                 |              |
|   P4    |      6       |     5      |                 |                 |              |
|   P5    |      8       |     2      |                 |                 |              |

gantt table - p1(0-3),p2(3-9),p3(9-13),p5(13-15),p4(15-20)

### Priority Based Scheduling

Each process is assigned a priority value based on criteria such as memory requirements, time requirements, other resource needs, or the ratio of average I/O to average CPU burst time.

The process with the highest priority is selected for execution first. If there are multiple processes sharing the same priority, they are scheduled in the order they arrived, following a First-Come, First-Served approach.

- **Criteria** - Priority
  - **Tie-Breaker** - FCFS
- **Type** - both

#### Problem 1

| Process | Arrival Time | Burst Time | Priority     | Completion Time | Turnaround Time | Waiting Time |
| ------- | ------------ | ---------- | ------------ | --------------- | --------------- | ------------ |
| P1      | 0            | 4          | 4            |                 |                 |              |
| P2      | 1            | 2          | 5            |                 |                 |              |
| P3      | 2            | 3          | 6            |                 |                 |              |
| P4      | 3            | 1          | 10 (Highest) |                 |                 |              |
| P5      | 4            | 2          | 9            |                 |                 |              |
| P6      | 5            | 6          | 7            |                 |                 |              |

non-preemptive gantt table - p1(0-4),p4(4-5),p5(5-7),p6(7-13),p3(13-16),p2(16-18)
preemptive gantt table - p1(0-1),p2(1-2),p3(2-3),p4(3-4),p5(4-6),p6(6-12),p3(12-14),p2(14-15),p1(15-18)

#### Problem 2

| Process | Arrival Time | Burst Time | Priority    |
| ------- | ------------ | ---------- | ----------- |
| P1      | 0            | 7          | 6           |
| P2      | 1            | 4          | 4           |
| P3      | 2            | 6          | 3           |
| P4      | 3            | 2          | 1 (Highest) |
| P5      | 4            | 3          | 5           |
| P6      | 6            | 5          | 2           |

preemptive gantt chart - p1(0-1),p2(1-2),p3(2-3),p4(3-5),p3(5-6),p6(6-11),p3(11-15),p2(15-18),p5(18-21),p1(21-27)

## problem with priority based scheduling

1. **Starvation** - can be solve through aging

## Problem with SJF and SRTF

1. **Starvation** - if shorter process keep coming then longer process must wait for indefinate time
2. **No fairness**
3. **Practical Implementation is not possible**

# Questions

## Unicore vs multicore processor

A **multi-core processor** has multiple cores in one CPU, allowing it to run several tasks simultaneously. This improves performance, multitasking, and efficiency compared to single-core processors.

## Does multiple cores mean multiple CPSs ?

Multiple cores don’t mean multiple CPUs — they’re multiple processing units within a single CPU chip, sharing memory and resources but handling tasks in parallel for faster performance.

## Which of the following state is/are initiated by process itself ?

1. Running
2. Ready
3. Terminated
4. Blocked

**ans:** 3 & 4

## A process which has just terminated but has to relinquish its resource is called ?

1. Suspended Process
2. Zombie Process
3. Blocked Process
4. Terminated Process

**ans:** 2

## Which scheduler reduces the degree of multi-programming ?

1. short-term
2. long-term
3. mid-term
4. long-term and mid-term both

**ans:** 3
